===============JPA=============================================
@Entity
    -> JPA가 사용하는 객체라는 뜻을 의미, 이 어노테이션이 없을경우 JPA가 인식하지못한다.
    JPA를 사용해서 Table과 매핑할 클래스는 @Entity 필수.
    -> 주의점
        1) 기본 생성자 필수(파라미터가 없는 public 또는 protected 생성자)
        2) final 클래스, enum, interface, inner 클래스 사용 X
        3) 저장할 필드에 final사용 X
    -> @Entity 속성
        1) name 속성
            JPA에서 사용할 엔티티 이름을 지정한다.
            기본값: 클래스 이름을 그대로 사용, 같은 클래스 이름이 없을경우 가급적 기본값 사용.

@Table
    -> @Table은 엔티티와 매핑할 테이블을 지정한다.
    -> @Table 속성
        1) name : 매핑할 테이블 이름(기본값은 엔티티이름)
        2) catalog : 데이터베이스 catalog 매핑
        3) schema : 데이터베이스 schema 매핑
        4) uniqueConstraints(DDL) : DDL 생성시 유니크 제약 조건 생성

@Id
    -> 테이블의 Primary Key와 매핑하는 용도
    -> 직접 할당할경우 @Id만 사용

@GeneratedValue(strategy = GenerationType.IDENTITY)
    -> 자동으로 값을 할당할때 사용하는 어노테이션
    -> 속성
        -IDENTITY : 데이터베이스에 위임 (MYSQL 의 AUTO_INCREMENT 처럼 동작)
            -> 기본 키 생성을 DB에 위임.
            -> 주로 MySQL, PostgreSQL, SQL Server, DB2에서 사용(MySQL의 AUTO_INCREMENT)
            -> JPA는 보통 트랜잭션 커밋시점에 INSERT SQL을 실행
            -> AUTO_INCREMENT는 DB에 INSERT SQL을 실행한 이후에 ID값을 알수있다.
            -> IDENTITY 전략은 em.persist()시점에 즉시 INSERT SQL을 실행하고 DB에서 식별자를 조회

        -SEQUENCE : 데이터베이스 시퀀스 오브젝트 사용 (ORACLE) [@SequenceGenerator 필요]
            속성으로는
            -name : 식별자 생성기 이름   (필수)
            -sequenceName : DB에 등록되어있는 시퀀스 이름    (default = hibernate_sequence)
            -initialValue : DDL 생성시에만 사용, 시퀀스 DDL을 생성할때 처음 1 시작하는 수를 지정한다.
            -allocationSize : 시퀀스 한 번 호출에 증가하는 수(성능 최적화에 사용됨, DB 시퀀스 값이 하나씩 증가하도록 되어있을경우
                              반드시 1로 설정해야만함, default = 50)
                              DB에는 미리 50개를 올리고, 내부 메모리에서 1씩 올리면서 사용하다가, 50에 다다르면 50을 추가하여 DB에 update.
                              동시성 이슈가 없도록 할수있다는데..
            -catalog, schema : 데이터베이스 catalog, schema 이름

        -TABLE : 키 생성용 테이블 사용, 모든 DB에서 사용       [@TableGenerator 필요]
            -> 키 생성 전용 테이블을 하나 만들어서 DB 시퀀스를 흉내내는 전략.
            -> 장점으로는 모든 DB에 적용가능하다. 단점으로는 성능면이..
            -> SEQUENCE 처럼 여러 속성이 있는데, 비슷하게 initialValue, allocationSize를 통해 최적화를 하는듯
        -AUTO : 방언에 따라 자동 지정, 기본값(defalut)

@Column(name = "Column명",length = 길이 )
    -> 객체의 필드를 테이블의 Column과 매핑한다. 만일 @Column 이 생략되어있을경우 객체의 필드를 테이블의 Column과 매핑한다.
    만일 스프링부트와 통합해서 사용할경우 itemName -> item_name으로 알잘딱 변환해준다.
    -> @Columns 속성
        1) unique - unique 속성 여부
        2) length - 길이 제한
        3) insertable, updatable - 등록, 변경가능 여부
        4) nullable(DDL) - null값의 허용 여부
        5) columnDefinition - DB column정보를 직접 줄수있다. ex) varchar(100) default 'EMPTY'
        6) precision, scale(DDL) - BigDecimal 타입에서 사용한다. precision은 소수점을 포함한 전체 자릿수,
        scale은 소수의 자릿수를 말한다. double, float 타입에는 적용되지않는다.

@Enumerated
    -> 객체에서 Enum 타입을 사용하고싶을때, @Enumerated 를 사용하면된다. Enum타입 매핑
    ->@Enumrated 속성
        1) String  : enum 이름을 데이터베이스에 저장
        2) ORDINAL : enum 순서를 데이터베이스에 저장(default)
    ## ORDINAL 속성은 사용하지말자.. ## 이유는 나중에 ENUM 타입을 추가할때에 문제가 생길수도있으므로.

@Temporal
    -> 시간 관련 정보를 사용하고싶을 때. 날짜 타입 매핑
    -> 최신 버전에는 LocalDate, LocalDateTime을 사용하면 생략가능하다.(하이버네이트 최신버전 지원)

@Lob
    -> varchar를 넘어서는 큰 객체를 사용하고싶을경우 사용하는 어노테이션 BLOB, CLOB 매핑

@Transient
    -> 해당 필드는 메모리에서만 사용한다는 의미. DB에서 Column이 생성되지않는다.



private final EntityManager em;
    -> JPA는 실제 사용시 EntityManager 의존관계 주입을 받아야한다.
    원래는 EntityManager 설정을 여러부분 해야하지만, Springboot사용시 그런부분은 알아서 해주므로 주입받아서 사용만하면 된다.


Entity 설계시 주의점
1) Entity에는 가급적 @Setter를 사용하지말자. 이후 실무에서 변경포인트가 너무많아서 유지보수가 어려울수있다.
2) 모든 연관관계는 지연로딩으로 설정하자.즉시로딩(EAGER)을 예측이 어렵고, 어떤 SQL이 실행될지 추척하기 어렵다.
특히 JPQL실행시 N+1문제가 자주발생한다. 실무에서 모든 연관관계는 (LAZY)로 설정하고, 만일 연관된 엔티티를
DB에서 함께 조회해야 할경우 fetch Join 또는 Entity 그래프 기능을 사용한다.
3) @OneToOne , @ManyToOne 처럼 N -> 1 로 가는 관계는 기본적으로 즉시로딩(EAGER)로 설정되어있으므로,
수동으로 LAZY 설정을 해줘야한다. ex) @ManyToOne(fetch = FetchType.LAZY)
1 -> N 은 LAZY가 기본이다.
4) 컬렉션은 필드에서 초기화 하자. (NUll 문제에서 안전, 하이버네이트에서 엔티티를 영속화할때 문제가생길수도있다.)

변경감지와 병합(merge)?
-준영속 엔티티?
    -> 영속성 컨텍스트가 더는 관리하지 않는 엔티티를 의미한다.
    ex) JPAshop에서 Book객체 수정을 시도할때 Book객체는 이미 DB에 한번 저장되어서 식별자가 존재한다. 이렇게 임의로 만들어낸 엔티티도
    식별자를 가지고 있으면 준영속 엔티티로 볼수있다.

-변경감지
    -> dirty checking (Entity의 속성이 변경되는 순간을 감지한다) / 트랜잭션 커밋시점에 알아서 바꿔줌

-문제점..?
    ->기본적으로 준영속 엔티티는 JPA가 관리하지않기때문에 변경감지가 일어나지않는다

-준영속 엔티티를 수정하는 방법2가지
    -변경 감지 기능사용(dirty checking)
        -> 영속성 컨텐스트에서 엔티티를 다시 조회한후 데이터를 수정하는 방법.
        ex) @Transactional
            void update(Item itemParam){                                //itemParam = 파라미터로 넘어온 중영속 상태의 엔티티
                Item findItem = em.find(Item.class, itemParam.getId()); //같은 엔티티를 조회한다.
                findItem.setPrice(itemParam.getPrice());                //데이터를 수정한다.
        트랜잭션 안에서 엔티티를 다시 조회, 변경할 값을 선택 -> 트랜잭션 커밋 시점에 변경 감지(Drity Checking)이 동작해서
        데이터베이스에 UPDATE SQL을 실행한다.   MemberService에서 updateItem 참고.

    -병합(merge) 사용
        ->병합은 준영속 상태의 엔티티를 영속 상태로 변경할 때 사용하는 기능이다.
        ex) @Transactional
            void update(Item itemParam){    //itemParam : 파라미터로 넘어온 준영속 상태의 엔티티
                Item mergeItem = em.merge(item);
                }
        병합시 동작 방식을 간단히 정리
        1. 준영속 엔티티의 식별자 값으로 영속 엔티티를 조회한다.
        2. 영속 엔티티의 값을 준영속 엔티티의 값으로 모두 교체한다.(병합한다.)
        3. 트랜잭션 커밋 시점에 변경 감지 기능이 동작해서 데이터베이스에 UPDATE SQL이 실행
        주의: 변경 감지 기능을 사용하면 원하는 속성만 선택해서 변경할 수 있지만, 병합을 사용하면 모든 속성이
        변경된다. 병합시 값이 없으면 null 로 업데이트 할 위험도 있다. (병합은 모든 필드를 교체한다.)

    -가장 좋은 해결 방법
     1)엔티티를 변경할 때는 항상 변경 감지를 사용하세요
     2)컨트롤러에서 어설프게 엔티티를 생성하지 마세요.
     3)트랜잭션이 있는 서비스 계층에 식별자( id )와 변경할 데이터를 명확하게 전달하세요.(파라미터 or dto)
     4)트랜잭션이 있는 서비스 계층에서 영속 상태의 엔티티를 조회하고, 엔티티의 데이터를 직접 변경하세요.
     5)트랜잭션 커밋 시점에 변경 감지가 실행됩니다

영속성 컨텍스트
-엔티티를 영구 저장하는 환경?
-영속성 컨텍스트는 논리적인 개념, 엔티티 매니저를 통해서 영속성 컨텍스트에 접근한다.

영속성 컨텍스트의 이점
-1차 캐시, 동일성(identity)보장, 트랜잭션을 지원하는 쓰기 지연(transcational write-behind),
 변경 감지(Drity Checking), 지연 로딩(Lazy Loading)
    1)1차 캐시?    [영속성 컨텍스트 내부에 있음]
        -> 만일 EntityManager.find()를 통해 객체를 찾을때 JPA는 DB에 바로 쿼리를 보내는 것이 아닌 1차캐시를 먼저 본다.
        -> 만일 1차캐시에 원하는 객체가 없을경우 DB에서 조회하여 1차캐시에 저장한다.
        -> 1차캐시는 ID 와 Entity 같은걸로 구성되어있다고 생각하면 편하다.

    2) 영속 엔티티의 동일성 보장
        -> 1차 캐시로 반복 가능한 읽기등급의 트랜잭션 격리 수준을 DB가 아닌 애플리케이션 차원에서 제공
        즉 같은 객체를 두번 가져와도 == 비교가 가능하다.(동일성 보장)

    3) 엔티티 등록(트랜잭션을 지원하는 쓰기 지연)
        ->EntityManger는 트랜잭션을 시작한뒤, em.persist()를 해도 insert SQL을 DB에 보내지않는다.
        commit을 해야 INSERT SQL을 보낸다. persist는 1차캐시(영속성 컨텍스트)에 넣는것이기 때문에 가능한것인듯.
        실제로 쿼리를 날리는 부분은 flush 라고한다. flush를 하기전 쓰기 지연 SQL저장소에 넣고, 한번에 쿼리를 날리는듯.

    4) 엔티티 수정 (변경감지)
        -> 영속성 엔티티는 .setter같은걸로 수정을 해도 commit전에 변경을 감지하여 쿼리를 변경해서 보낸다. 즉
        따로 em.update()이런 코드가 필요하지않다. 예시로 DB에서 특정 엔티티를 꺼낸뒤 수정하면, commit 시점에
        변경을 감지하여 DB에 update쿼리를 보낸다.
        원리는 1차캐시. Id, Entity에 더불어 스냅샷이 있어서, DB에서 엔티티를 조회하였을때의 엔티티를 스냅샷에 저장한다.
        그뒤 commit 시점에 현재 Entity와 스냅샷을 비교하여 변경된 부분이 있을경우 update쿼리를 쓰기 지연SQL 저장소에 넣는다.

    5) 엔티티 삭제
        -> 엔티티를 삭제한다.

플러시(flush)?
-> 영속성 컨텍스트의 변경내용을 DB에 반영
-> 플러시가 발생했을경우?
    1)변경 감지
    2)수정된 엔티티 쓰기 지연 SQL저장소에 등록
    3)쓰기 지연 SQL저장소의 쿼리를 DB에 전송(등록,수정,삭제)
-> 옵션으로는 FlushModeType.AUTO(커밋이나 쿼리를 실행할때 플러시(기본)), FlushModeType.COMMIT(커밋할 때만 플러시)
-> 영속성 컨텍스트를 비우지 않는다.
-> 영속성 컨텍스트의 변경내용을 DB에 동기화한다.
-> 트랜잭션이라는 작업 단위가 중요하다. 커밋 직전에만 동기화 하면 된다.

영속성 컨텍스트를 플러시하는방법.
1) em.flush() - 직접호출
2) 트랜잭션 commit - 플러시 자동호출
3) JPQL 쿼리 실행 - 플러시 자동호출

엔티티의 생명주기
-비영속 (new/transient)
    영속성 컨텍스트와 전혀 관계가 없는 새로운 상태
    ex) 객체를 생성한 상태

-영속 (managed)
    영속성 컨텍스트에 관리되는 상태
    ex) em.persist(member);
    객체를 생성한 뒤 EntityManager를 통해 persist한 상태. persist는 영속성 컨텍스트에 객체를 넣는다는 의미로 알수있다.
    persist는 DB에 쿼리를 보내는 역할이 아니다. 실제로는 영속상태인 객체를 commit 시점에 쿼리로 DB에 전달한다.

-준영속 (detached)
    -> 영속성 컨텍스트에 저장되었다가 분리된 상태, 영속성 컨텍스트가 제공하는 기능을 사용 못한다.
    -> 준영속 상태로 만드는 방법.
        1)em.detach();      -> 이제부터 JPA에서 관리하지않는다(영속성컨텍스트에서 벗어남)
        2)em.clear();       -> 영속성 컨텍스트를 완전히 초기화
        3)em.close();       -> 영속성 컨텍스트를 종료

-삭제 (removed)
    영속성 컨텍스트에서 삭제된 상태

엔티티 매핑?
-객체와 테이블 매핑: @Entity @Table
-필드와 컬럼 매핑 : @Column
-기본 키(PK) 매핑 : @Id
-연관관계 매핑: @ManyToOne, @JoinColumn

데이터베이스 스키마 자동 생성
-DDL을 애플리케이션 실행 시점에 자동 생성
-테이블 중심 -> 객체 중심
-데이터베이스 방언을 활용해서 데이터베이스에 맞는 적절한 DDL사용
-이렇게 생성된 DDL은 개발 장비에서만 사용
-운영서버에서는 사용하지 않거나, 적절히 다듬어서 사용해야한다.
-hibernate.hbm2ddl.auto (persistence.xml에 추가) 의 속성
    1) create : 기존 테이블 삭제후 생성 (DROP + CREATE)
    2) create-drop : create와 같으나 종료시점에 테이블 DROP
    3) update : 변경분만 반영(운영DB에는 사용하면안된다)
    4) validate : 엔티티와 테이블이 정상 매핑되었는지만 확인
    5) none : 사용하지않는다.
##운영장비에는 절대 create, create-drop, update를 사용하면 안된다##

기본키 매핑
@Id, @GeneratedValue

권장하는 식별자 전략
1) 기본 키 제약 조건: NOT NULL, UNIQUE, (변하지않고 유일)
2) 미래까지 이 조건을 만족하는 자연키는 찾기 어렵다. 대리키(대체키)를 사용하자.
3) 주민등록번호또한 기본 키로 적절하지않을수있다(미래에 정책변경등)
4) 권장하는 바로는 Long + 대체키 + 키 생성전략 사용

연관관계 매핑
-방향(Direction) : 단방향, 양방향
-다중성(Multiplicity) : 다대일(N:1), 일대다(1:N), 일대일(1:1), 다대다(N:N) 이해
-연관관계의 주인(Owner) : 객체 양방향 연관관계는
-연관관계는 관계형 DB에서 PK 와 FK로 매핑했던거같은데..

단방향 연관관계?
ex)
    ->Member에는 id,Team team, username 이라는 필드가있고, Team은 id,name 가 있다고 할때.
@ManyToOne @JoinColumn
@ManyToOne : 현재 엔티티와 연관관계가 어떤 연관관계인지 명시
    ->ex)하나의 팀에 여러명의 회원이 들어갈수있다. 그러므로 회원(Member)입장에서보면 팀(team)과 관계는 다대일(N:1)관계, 팀의 입장에서보면 회원과는 일대다(1:N)관계이다.
@JoinColumn : 어떤 Column과 매핑관계인지 명시
    -> ex) Team의 PK가 TeamId 일경우 @JoinColumn(name = "TeamId")


양방향 연관관계?
    ->Member에는 id,Team team, username 이라는 필드가있고, Team은 id,name,List<members>가 있다고 할때
-양쪽으로 참조할수 있게 만든 관계
양방향 객체 연관관계의 경우 서로에게 참조할수있게끔 필드를 넣어줘야한다. 그러나 DB에서는 PK,FK로 양방향 연관관계가 매핑된다.
즉 DB는 단방향 연관관계와 다른점이 없이 매핑한다.
@OneToMany와 같은 연관관계매핑 어노테이션을 사용할떄 속성으로 mappedBy 를 사용하는데, 여기에 어느 필드와 연관관계가 있는지 명시해야한다.
    ex)@OneToMany(mappedBy = "team")


연관관계의 주인? mappedBy?
-> 객체와 테이블간의 연관관계를 맺는 차이를 알아야한다.
-> 객체는 연관관계가 되는 포인트가 2개이다.
    1)Member -> team
    2)team -> Member
    어쩌면 단방향 연관관계를 2개 맺었다고 볼수있다.
    그러므로 객체의 경우 양방향으로 참조하려면 단방향 연관관계를 2개 만들어야한다.

-> 테이블은 연관관계가 되는 포인트가 1개이다.
    1)TEAM_ID(FK) <-> TEAM_ID(PK)
    서로 TEAM_ID를 통해 서로의 값에 대해 참조할수있다.
    MEMBER.TEAM_ID 외래 키 하나로 양방향 연관관계를 가진다.(FK,PK가 반대여도 가능)

여기서, 만약 연관관계가 만들어졋을경우가 문제가 된다.
MEMBER객체에서 TEAM_ID가 변경되었을경우 TEAM의 TEAM_ID가 변경되어야하는가? 아니면 TEAM 에서 TEAM_ID가 변경되었을때 MEMBER의 TEAM_ID가 변경되어야하는가?
(DB에서는 어느 한쪽은 참조값을 변경할수없다.그러나 객체에서는 서로 참조값 변경이 가능하기떄문에 문제가 발생하는 것 같다).
한마디로 기준값이 무엇인가? Member 참조값이 변경되었을때 바뀌어야하는가? Team 참조값이 변경되었을때 바뀌어야하는가?
이것도 이해못하면 내가보고있는게 아닐것같은데, 일단 DB에서는 PK는 변경할수없다. 그러므로 PK값을 따라감.
여기서 나오는것이 연관관계의 주인(Owner)

연관관계의 주인
->양방향 매핑 규칙
    1) 객체의 두 관계중 하나를 연관관계의 주인으로 지정
    2) 연관관계의 주인만이 외래 키를 관리(등록,수정)
    3) 주인이 아닌쪽은 읽기만 가능
    4) 주인은 mappedBy 속성 사용X
    5) 주인이 아니면 mappedBy 속성으로 주인 지정
-> 외래 키가 있는 곳을 주인으로 정해라
    ########비즈니스 로직을 기준으로 연관관계의 주인을 선택하면 안된다.#######
    불편하다면 연관관계 편의메서드를 만들자..

양방향 매핑시 가장 많이 하는 실수
1) 연관관계의 주인에 값을 입력하지않음.
    ex) 역방향(주인이 아닌 방향)만 연관관계를 설정
    단, 순수한 객체 관계를 고려하면 항상 양쪽 다 값을 입력해야한다. 만일 직접 flush, clear를 해준상태라면 문제가 없을수도있지만 아니라면
    find를 통해 객체를 참조하였을때 1차 캐시에 이미 있는값이기 그 1차캐시에 있는값이 받아와질수있다. 이러면 하나만 값을 넣어주었을경우
    서로 값이 다른 객체로 확인될것이다.. 그러므로 일단 항상 양쪽에 값을 넣어줄수있도록 하자..(team에도 값 넣기, member에도 값 넣기)
    -연관관계 편의 메소드를 넣어주기.
    -양방향 매핑시 무한 루프를 주의해야한다. ex) toString(), Lombok, JSON 생성 라이브러리
    -Controller에서는 Entity를 반환하지말자.(JSON으로 반환)
#######정리하자면################
    1)단방향 매핑만으로도 이미 연관관계 매핑은 완료
    2)양방향 매핑은 반대 방향으로 조회(객체 그래프 탐색)기능이 추가된것 뿐이다.
    3)JPQL에서 역방향으로 탐색할 일이 많다
    4)단방향 매핑을 잘 하고 양방향은 필요할 때 추가해도 된다.(테이블에 영향을 주지않는다)
    JPA로 DB 설계할시 단방향 매핑만으로 설계를 완료해야한다.


===============Spring==========================================
@Repository @Service
ComponentScan의 대상이 되어서 자동으로 Bean 등록이 된다. 부가적인 기능들이 있긴하다

@Autowired
SpringBean에 의존성 주입을 위해 사용.

@RestController
    -> RestController는 반환 값으로 View를 찾는게 아니라, HTTP 메세지 바디에 바로 입력한뒤 리턴한다.
    만약 클래스타입에 적용하였다면 그 클래스내부 메서드들에 전부 적용된다.

@RequestMapping
    -> RequestMapping("주소")."주소" URL 호출이 오면 메서드가 실행되도록 매핑한다.
    대부분의 속성을 배열로 제공하므로 다중설정이 가능하다 ex) ("주소1","주소2")
    메서드 적용할시 ex) @RequestMapping(value="주소",method = RequestMapping.GET) -> GET방식으로 오는것만 메서드실행
    만일 속성을 넣지않았을경우 HTTP 메서드와 무관하게 모두 호출된다 (GET, HEAD, POST, PUT, PATCH, DELETE)

@Transactional
기본적으로 데이터변경을 하는부분에서는 Transactional이 필요하다. 단 이 어노테이션은 두가지 제공방식이 있는데,
하나는 Spring 이고 하나는 javax에서 제공하는 것이다. 물론 Spring을 사용하고있는 입장에서는 Spring에서 제공하는것을
사용하는것을 권장.

@SpringBootTest
Spring을 실행시킨 상태로 테스트를 진행하고싶다면 사용하는 어노테이션. 만일 제공하지않을경우 @Autowired 이 실패한다.

PathVariable(경로변수)
    -> 리소스 경로에 식별자를 넣는 방법.
    ex) @GetMapping("/mapping/{userId}")
        public String mappingPath(@PathVariable("userId") String data)
        -> Get방식으로 오는 접근에는 메소드를 실행한다. userId는 경로변수로서 @PathVariable("userId")를 통해서 받아올수있다.
        받아온 값을 String 타입으로 받을수있다.
    -> 리소스 경로에 식별자가 여러개 사용할수있다.
    ex) @GetMapping("/mapping/uesrs/{userId}/orders/{orderId}")
        public String mappingPath(@PathVariable String userId, @PathVariable Long orderId)
        -> 각각의 {userId},{orderId} 라는 경로변수를 @PathVariable로 받아올수있다.

회원 관리 API 예시
-회원 목록 조회 GET (/user)
-회원 등록 POST    (/users)
-회원 조회 GET     (/users/{userId})
-회원 수정 PATCH   (/users/{userId})
-회원 삭제 DELETE  (/users/{userId})

클라이언트에서 서버로 요청 데이터를 전달할 때는 주로 다음 3가지 방법을 사용한다.
1) GET - 쿼리 파라미터
    - /url?username=hello&age=20
    - 메세지 바디 없이, URL의 쿼리 파라미터에 데이터를 포함해서 전달
    - 예) 검색, 필터, 페이징등에서 많이 사용하는 방식
2) POST - HTML Form
    - content-type : application/x-www-form-urlencoded
    - 메세지 바디에 쿼리 파라미터 형식으로 전달 username=hello&age=20
    - 예) 회원 가입, 상품 주문, HTMLForm 사용
3) HTTP message body에 데이터를 직접 담아서 요청
    - HTTP API에서 주로 사용, JSON, XML, TEXT
    - 데이터 형식은 주로 JSON 사용
    - POST, PUT, PATCH

만약 1) 방식이라면 HttpServletRequest의 request.getParameter()를 사용하면 다음 두가지 요청 파라미터를 조회할수있다.
ex) /request-param?username=hello&age=20 라는 파라미터로 쿼리 파라미터를 전송했다고 하자.

Controller에서 사용하는 Model?
Model = View단에서 사용하는 데이터를 넘길때 사용하는 객체.
ex) model.addAttribute("객체명","객체데이터") Map과 유사한 데이터형식으로 넘길수있다.

@Transactional 이 Test단에서 실행될경우, 일반적으로 테스트가 끝난뒤 Rollback을 한다.
만일 원치않는다면 @Rollback(false)로 하면된다.

테스트할때 외부DB를 사용하지않고, 내부에서 만든(잠시 테스트용도로)DB를 사용하고싶을경우
Test폴더안에 resources폴더를 만든다. 이렇게 되면, Test할때에는 Test폴더안에있는 resources폴더에 있는 설정들을 적용한다.
여기에 application.properties라는 이름의 파일을 만든뒤 인메모리 기능을 지원하는 DB에서 설정값을 변경하면된다.
Mysql은 인메모리 기능을 지원하지않아서 관둡시다..

===============Lombok==========================================
@RequiredArgsConstructor
초기화 되지않은 final 필드, @NonNull이 붙은 필드에 대해 생성자를 생성한다.
즉 의존성 주입을 하기위해서 사용하는듯.

@Getter @Setter
이 어노테이션이 붙은 필드에는 자동적으로 getXXX(), setXXX()를 생성해준다.

@NoArgsConstructor
파라미터가 없는 기본 생성자 생성

@AllArgsConstructor
모든 필드값을 파라미터로 받는 생성자를 생성

@ToString
toString()메소드 자동생성

@Data
@Getter @Setter @RequiredArgsConstructor @ToString @EqualsAndHashCode 를 자동생성해준다

=================DB============================================
DataBase?
-> 데이터의 집합. ex) 전화번호부 [이름]-[전화번호]
-> 현재는 접근 가능한 인터페이스를 가지고있으면서 컴퓨터화되어있는 데이터의 구조화된 집합

DBMS, RDBMS?
--> DMS는 DataBase Management System(DB관리 시스템)
--> RDBMS 은 관계형 데이터베이스 관리 시스템인듯?
ex) PostgreSQL, MySQL, Oracle DB, SQLite들은 기본적으론 데이터베이스 관리 시스템이다.

SQL? MySQL?
--> SQL은 데이터베이스 데이터에 접근할때 사용하는 언어 = 구조화된 쿼리 언어
ex) Find All Users Who Are 18 Or Older (모든 유저들중 나이가 18이거나 더많은사람을 찾아라)
    = SELECT * FROM Users WHERE Age  >= 18; (SQL로 보낸 같은 의미를 가진 명령문)
--> MySQL은 SQL을 구현하는 DB 관리 시스템

Table?
--> 데이터베이스(관계형)는 여러개의 테이블로 이루어져있다. 테이블은 데이터를 담고있으며,
데이터의 형태와 형식을 설명하고 그 형식을 따른 데이터들을 수집하여 보관한다.
Table에는 Field(Columns),Type(data_type), Null(값이 Null일수있는지),Key,Default(기본값)등을 설정할수있다.
ex) 고양이의 데이터베이스가 있어야한다고 치자. 그렇다면 이름, 종, 나이를 넣는다고 하였을때
각 테이블 Columns의 제목(Headers)는 각각 Name, Breed, Age 이다. 그 이후 각 행(Rows)에 맞춰서
데이터가 들어가게된다. 이때 같은 행에 위치한 데이터들은 하나의 연관된 데이터라고 볼수있다.(엑셀마냥)

Data Type?
--> 테이블에는 각각의 Columns에 들어가게될 데이터형식을 지정해야만 한다. int, String(VarChar), char 등등..
데이터의 일관성을 부여하여 예상외의 예외를 줄일수있다. 또한 최대 문자수를 지정해줄수있다.

mysql주석은 --로 표현할수있다.

Primary Key?
--> unique identifier (고유 식별자) 로서 테이블에서 고유한 값을 가지게 하여
모든 column에 해당하는 값이 동일하더라도 primary key를 활용하여 구별할수있다.
기본적으로 Not null 속성을 포함하며, 중복될수없고, AUTO_INCREMENT 속성을 추가하여 기본적으로 1씩 추가하게끔 만들수있다.

STRING FUNCTION?
SQL에서 실행할수있는 간단한 함수인듯(엑셀처럼)
CONCAT, SUBSTRING, REPLACE, REVERSE, CHAR_LENGTH, UPPER, LOWER 등등..

SELECT * FROM **
--> *은 전체를 의미한다. **에서 전체를 조회한다.

ORDER BY #
--> #의 값 기준으로 오름차순 정렬

ORDER BY DESC #
--> #의 값 기준으로 내림차순 정렬

DROP TABLE #
--> #이라는 테이블 삭제

USE <database name>
--> 이 데이터베이스를 사용

SELECT database()
--> 현재 사용하는 데이터베이스

CREATE TABLE <tablename>
--> (
        column_name data_type,
        column_name data_type
    );
새 테이블을 만들려면 테이블 이름과 데이터타입, column명을 명시해야줘야한다.
ex) CREATE TABLE cats
        (
            name VARCHAR(100) not Null default 'unnamed',   #name 에는 100글자까지 들어갈수있고 null일수없으며 기본값이있다.
            age INT                                         #age 에는 글자수 제한이 없고 null일수있으며 기본값이 없다.
            cat_id int not null PRIMARY key AUTO_INCREMENT  #cat_id 는 고유식별자이고, 자동적으로 1씩 증가한다.
        );

SHOW TABLES
--> 현재 위치한 데이터베이스에서 존재하는 테이블확인

SHOW COLUMNS FROM <table_name>
--> <table_name>에 정의되어있는 columns 정보 확인
DESCRIBE <table_name>이나 DESC <table_name> 또한 동일한 쿼리문이다.

DROP TABLE <table_name>
--> <table_name>이란 이름의 TABLE을 삭제한다. ##주의해서 사용해야한다. 테이블에 많은 정보를 담고있었을경우 되돌릴수없다.

INSERT
--> INSERT 키워드를 사용하여 데이터를 삽입할수있다.
ex) INSERT INTO <table_name>(column_name1, coulmn_name2) VALUES ('data',data);
이때 column_name1에 들어갈 내용이 'data' 이고 column_name2 에 들어갈 내용이 data이다.
각 선언한 순서대로 넣어지게된다는점을 유의해야한다(데이터형식과 원치않는 내용이 들어가는것을 방지하기위해서)
다중삽입 VALUES ('data',data),('data',data), ... 이런식

SELECT * FROM <table_name>
--> <table_name>에 있는 데이터들을 전부 조회

쿼리문에는 큰따옴표보다 작은 따옴표를 사용하는것이 혹여나 다른 Db와의 혼란을 줄일수있다.
"mario's pizza" = 'mario\'s pizza';

CRUD
--> CREATE, READ, UPDATE, DELETE
DB에서 대개 기본적으로 지원하는 기능

SELECT  (READ)
--> SELECT (Column_name) FROM (TABLE_name)  2개이상의 Column을 조회할수도있음 , 으로 구분하는듯
SELECT 은 기본적으로 조회하고싶은 Column명을 적어주고, FROM으로 조회할 TABLE을 선택한다음 WHERE로 정보를 추려서 가져온다.

Update  (UPDATE)
--> UPDATE (TABLE_name) SET (변경할 column과 Row명)  WHERE(조건)
ex) UPDATE cats SET breed='shortHair' WHERE breed='Tabby' -> cats 테이블에서 breed가 Tabby인걸 shortHair로 바꾼다.

Delete  (DELETE)
--> DELETE FROM (TABLE_name) WHERE (조건);
ex) DELETE FROM cats WHERE name='Egg'; -> cats테이블에서 name='Egg'인 것을 삭제
#주의 DELETE FROM (TABLE)을 하면 TABLE 전체가 삭제되므로 주의해야한다.

WHERE
--> WHERE은 일종의 조건문과 같다.
ex) SELECT * FROM cats WHERE age>4; == cats 테이블에서 모든Column을 조회하는데, 그중 age값이 4보다 큰값만 조회

AS
--> Column 명을 해당쿼리문에 한하여 변경할수있다.
ex) SELECT cat_id as id, name FROM cats; -> cat_id라는 column이 id로 출력된다.

#문자열 함수를 사용할때에 Function()에서 ()를 띄어쓰기 하면 예외가 터지므로, 꼭 붙여서 사용하자
문자열 함수 예시
SELECT CONCAT(SUBSTRING(title,1,10),'...')as short_title FROM books;
SELECT CONCAT_WS('.',SUBSTR(author_fname,1,1),SUBSTR(author_lname,1,1)) as Initial From books;

CONCAT
--> 문자열을 결합,연결하는 함수.
ex) SELECT CONCAT('My','S','QL'); -> 'MYSQL'
ex) SELECT CONCAT(author_fname,author_lname) FROM books; ->fname+lname로 반환된 문자열 조회
#단 중간에 NULL값이 있다면 NULL이 반환되고, 숫자를 넣어도 문자열로 반환된다. CONCAT(f+l)로 column명이 나오는데
as 써서바꿀수있음

CONCAT_WS
--> CONCAT과 비슷하지만 첫번쨰 인자값에 넣은값들이 문자들이 연결되는 사이에 들어가게된다.
ex) SELECT CONCAT_WS(' - ', title, name) FROM books -> title - name 이런식으로 나옴

SUBSTRING
--> 문자열중 일부분을 반환    SUBSTRING(문자열,시작인덱스,시작인덱스부터 몇개까지 반환할건지)
ex) SELECT SUBSTRING('abcdefg',3); -> cdefg
ex) SELECT SUBSTRING('abcdefg',FROM 3) -> cdefg
ex) SELECT SUBSTRING('abcdefg',3,2) ->cd
#MYSQL은 인덱스번호가 1번부터 시작한다는점을 주의하자, 또한 인자값에 음수도 가능하다.
#SUBSTR() 또한 같은 의미.

REPLACE
--> 문자열 일부분을 변환
SELECT REPLACE (문자열,From_str,to_str) 문자열에서 From_str이라는 문자열이 to_str로 변환된다.
ex) SELECT REPLACE('Hello World','Hell','OuO') -> OuOo World
ex) SELECT REPLACE(title, ' ','-') FROM books;

REVERSE
--> 문자열을 반대로 반환
SELECT REVERSE('abc') -> cba
SELECT concat(author_fname, REVERSE(author_fname))as Test FROM books;

CHAR_LENGTH
--> 문자열의 길이 반환
ex) SELECT CHAR_LENGTH('Hello World') -> 11

LENGTH
--> 문자열의 Byte 길이반환

UPPER, LOWER
--> 문자열을 대문자로 바꾸거나 소문자로 변경
ex) SELECT UPPER('Hello World') -> HELLO WORLD
ex) SELECT LOWER('Hello Wrold') -> hello world
UCASE,LCASE 또한 같은 함수

INSERT
--> 문자열에 문자열을 삽입하는 함수   INSERT(str,pos,len,newstr)
ex) SELECT INSERT('Quadratic',3,4,'What') -> 'Quwhattic'
? 이정도면 거의 REPLACE이지만, 위치(pos)를 지정한뒤 그로부터 임의의 길이까지(len)을 전부
새로운 문자열로(newstr)로 대체한다는점에서 다르다.

LEFT, RIGHT
--> 문자열에서 왼쪽(오른쪽)에서 임의의 거리만큼 떨어져있는 문자를 반환
ex) SELECT LEFT('football',5) -> b
ex) SELECT RIGHT('basketball',5) -> t

REPEAT
--> 특정 문자열을 반복한것을 반환
ex) SELECT REPEAT('a',3) -> aaa

trim
--> 선행 및 후행 공백 제거
ex) SELECT TRIM('       hi       '); -> hi          (인자가없을경우 공백제거)
ex) SELECT TRIM(LEADING '.' FROM ''.....san antonio...') -> san antonio...  (선행 제거)
ex) SELECT TRiM(BOTH 'x' FROM 'xxxbarxxx') -> bar   (선행,후행 제거)
ex) SELECT TRIM(TRAILING 'x' FROM 'xxxbarxxx') -> xxxbar (후행 제거)
#단 단순 trim은 중간에 있는 공백은 제거하지않는다.

DISTINCT
--> 중복이 제거된 결과를 반환
ex) SELECT DISTINCT realsed_year from books
ex) SELECT DISTINCT CONCAT(author_fname,' ',author_lname) from books;
ex) SELECT DISTINCT author_fname, author_lname, released_year from books
-> 선택한 column중에서 모두 동일한 결과가 있을경우 제거

ORDER BY
--> 정렬 [1.기본적으로 우상향,
DESC 속성을 덧붙일경우 역순
ex) SELECT title, author_fname,author_lname FROM books ORDER BY 2;
-> author_fname을 기준으로 정렬(2번쨰 column)
ex) SELECT author_fname, author_lname from books ORDER BY author_fname,author_lname;
-> author_fname을 기준으로 먼저 정렬한뒤, author_lname을 기준으로 정렬

LIMIT
--> 결과값의 개수를 제한할수있다.
ex) SELECT * FROM books LIMIT 5 -> 결과값이 상위 5개만 출력된다.
ex) SELECT book_id, title, released_year FROM books ORDER BY released_year
    DESC LIMIT 1,6;             -> 상위 1번째부터 6개  출력

LIKE
--> 정확히 일치하는 것만이 아닌 특정부분을 포함하는경우에도 결과에 포함
ex) SELECT title, author_fname, author_lname FROM books WHERE author_fname='David';
        -> 정확히 author_fname이 'David' 인 결과만 출력
    SELECT title, author_fname, author_lname, FROM books WHERE author_fname LIKE '%da%'
        -> author_fname에 da가 포함될경우 출력
'%a%' 일치하는 부분을 찾고싶을떄  '____' -> 4의 길이를 가진 결과를 보고싶을떄
'da%' 라면 da로 시작하는 조건.   '%da%' 라면 da가 문자열 중간에 있는 조건.

COUNT
--> 가져오는 행의 개수를 알고싶을때
ex) SELECT COUNT(*) FROM books;
    -> books에서 가져오는 data가 몇개인지 세서 알려준다.
ex) SELECT COUNT(author_fname) FROM books;
    -> author_fname에 값이 있을때마다 세서 반환.
ex) SELECT COUNT(DISTINCT author_fname) FROM books;
    -> author_fname 에서 중복된 결과를 제와한 값을 세서 반환.
ex) SELECT title FROM books WHERE title LIKE '%the%';
    -> title columns에서 the를 포함한 결과를 세서 반환
이 때 (*)을 조건으로 COUNT를 한것과 (author_fname)을 조건으로 한 결과가 각각 다른데, 20개와 19개이다.
이유로는 NULL값이 들어가있는 데이터가 있는데,(*)의경우 그 조건까지 세지만, (author_fname)은 NULL을 포함시키지않는다.

GROUP BY
--> 특정한 테이블을 기준으로 또다른(논리적인)Table?그룹? 을 만듬.
ex) SELECT author_lname COUNT(*) FROM books GROUP BY author_lname;
    -> author_lname을 기준으로 그룹을 만들기 때문에 각각의 이름에 해당하는 논리테이블의 개수들을 세서 반환
    예를들면 (A, B, C)작가가 각각 (1,2,3)권씩 있는게 데이터베이스에 있다고치자. 그렇다면 저 쿼리를 넣었을시
    반환값은 Columns은 author_lname 과 count 이고, 각각 (A 1) (B 2) (C 3) 이다.
ex) SELECT CONCAT(author_fname,' ',author_lname) AS author , COUNT(*) FROM books GROUP BY author;
    -> fname과 lname을 합친 걸 기준으로 GROUP을 나눠서 각각의 그룹화된 테이블의 개수를 세서반환

GROUP BY(Having)
--> GROUP BY 에서 어떤 그룹을 결과에 포함할지를 정해줄수있다.(WHERE)
ex) SELECT title, AVG(rating) FROM full_review GROUP BY title HAVING COUNT(rating) >1;
    -> title로 그룹들을 만든뒤, 그 그룹중 rating이 1이상인것들만 결과에 반영

GROUP BY(ROLL UP)
--> GROUP BY 한 그룹들의 평균?
ex) SELECT released_year, AVG(rating) FROM review GROUP BY released_year WITH ROLLUP;
    -> 결과의 마지막에 전체 rating의 평균값을 출력. 즉 AVG,SUM 이런 계산하는 함수에 대해서 전체에 대한 함수를 실행해주는듯?

MIN MAX
--> 특정 데이터들의 MIN, MAX값을 반환
그룹화를 안하고 할경우
ex) SELECT MIN(released_year) FROM books;
    -> 가장 작은 연도의 값을 출력
ex) SELECT MAX(released_year) FROM books;
    -> 가장 큰 연도의 값을 출력
eX) SELECT MIN(author_lname) FROM books;
    -> 알파벳 순서로 가장 작은 값을 출력

SubQuery    (하위쿼리)
--> 쿼리문안에 ()로 구분한 쿼리문을 통해 비교적 복잡한 CRUD 를 수행할수있다
ex) SELECT * FROM Books WHERE pages = (SELECT MIN(pages) FROM books);
    -> pages가 가장 적은 데이터를 찾아서 그 데이터의 전체coulmns과 값을 반환
    만일 조건이 같은 값이 있다면 그 값또한 반환

SUM
--> 특정 Columns에 있는값들을 다 더하여 반환 (int)
ex) SELECT author_lname, SUM(pages) FROM books GROUP BY author_lname;
    -> author_lname을 기준으로 그룹을 만든뒤, 그 그룹별로 pages의 값들을 더하여 반환
만일 int형이 아닌경우 0으로 합산하여 반환한다.

AVG
--> 특정 Coulmns에 있는 값들의 평균을 반환 (int)
ex) SELECT AVG(released_year) FROM books;
    -> released_year의 평균을 반환.

DataType (데이터타입)
1) CHAR, VARCHAR 의 차이점??
    -공식문서에서도 두 개의 데이터타입은 비슷하지만, 저장과 회수하는 방법에 차이가있다고 적혀있다.
    -VARCHAR는 데이터의 최대 크기를 정하여 사용하지만, CHAR는 데이터의 크기를 정하고 사용한다.(만약 크기보다 적은 크기의 데이터가 입력된다면 공백을 넣어서 크기를 맞춘다)
    ex) 만일 CHAR(10)인데 데이터가 test만 들어왔다면, test______ 처럼 뒤에 공백을 추가한다.
    그러나 실제 CHAR 길이가 늘어날수록, VARCHAR가 저장공간을 더 많이 잡아먹는다. 예를들면 CHAR(4) 일경우 어떤 데이터여도 4Bytes 이지만
    VARCHAR의 경우 '_' = 1Byte '__' = 3Bytes '____' = 5Bytes 이다.
    - 그렇다면 CHAR는 고정된 길이의 문자에서 유용한데 어디에 사용하는것이 좋을까? ex) 나라 약자(kr,jp,CN) 또는 우편번호 또는 Y/N
    단순하게 고정된 크기를 받는다면 CHAR 사용하고, 아니면 VARCHAR를 사용하자.

2) INT, TINYINT, BIGINT = 정수
    -단순하게 각각의 타입은 저장할수있는 크기가 다르다. TINYINT = 1Bytes (-128~127), INT = 4Bytes (Int 최대 그거 ㅇㅇ), BIGINT = 8Bytes
    -만약 unsigend int 로 사용하고싶다면 (Columns INT UNSIGEND); 로 선언해주면된다.
    -정수 데이터타입에 실수를 넣는다면 ROUND()가 적용되서 들어간다. ex) 1.5 -> 2

3) DECIMAL, FLOAT, DOUBLE = 10진수?
    - 컴퓨터가 소수를 저장하는것은 많은 자원이 소모되므로, 여러 타입으로 구분한다. DECIMAL의 경우 정확한 10진수를 입력할수있다.
    - DECIMAL(5,2) 이면 5는 할당하고자 하는 숫자의 총데이터크기이고, 2는 소수점 자릿수를 나타낸다. (단 소수점 자리까지 포함한 총 데이터크기이다)
    ex) DECIMAL(5,2) -> 999.99 가 최대이다.
    - float, double의 경우 DECIMAL보다는 비용이 적게들면서 용량은 크다. 다만 정확도는 떨어진다.
    - float = 4 bytes, 소수점 7자리수까지. double = 8 bytes, 소수점 15자리수까지. 각 소수점을 넘어가게 되면 정확도가 떨어지게된다.
    만약 정확도가 별로 중요하지않거나 속도가 가장 중요할경우 double로도 충분히 다 할수있다. 정말 정확도가 중요하다면 DECIMAL or BIGINT

Dates & Times (날짜 또는 시간)
--> DATE는 날짜를 입력할수있는 형식을 의미한다. 대개 생년월일, 생일, 세계 수달의 날 등등..
    ex) YYYY-MM-DD
--> TIME은 시간을 입력할수있는 형식을 의미한다. 대개 알람, 몇 시간이 걸렷는지, 얼마나 지낫는지 등등.
    ex) HH:MM:SS
--> DATETIME 은 DATE와 TIME을 합한 형식을 의미한다.
    ex) YYYY-MM-DD HH:MM:SS
--> DB의 Table에서 새로운 Column들을 시간관련해서 넣어줄수있다.
    1.  created_at TIMESTAMP default CURRENT_TIMESTAMP
        =이 쿼리는 해당 행이 만들어 질때 이 Column의 TIMESTAMP가 기록된다.
    2.  upeate_at TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
        =이 쿼리는 주어진 행에 대해서 변경이 실행될때 이 Columns의 TIMESTAMP가 (기록)변경된다.

CURDATE CURTIME NOW
--> CURDATE = 현재날짜 CURTIME = 현재시간 NOW = CURDATE + CURTIME
ex) SELECT CURTIME(); -> 현재 시간이 형식에 맞춰서 반환.
ex) SELECT CURDATE(); -> 현재 날짜가 형식에 맞춰서 반환
ex) SELECT NOW()      -> CURTIME + CURDATE 가 DATETIME 형식에 맞춰서 반환

여러가지 쓸만한 날짜(요일)관련 함수
1) DAY(columns) => 일자만 출력 ex) 2000-11-11 -> 11;
2) DAYOFWEEK(columns) => 이 일자가 몇요일인지 숫자로 출력 ex) 2000-11-11 -> 7 [0 = 일요일 ~ 7 = 토요일]
3) DAYOFYEAR(columns) => 이 일자가 1년중 며칠째인지 출력 ex) 2000-11-11 -> 316 [1년 365(366)일 중에 316일째]
4) MONTHNAME(columns) => 해당하는 달이 어느달인지 출력 ex) 2000-11-11 -> November
5) WEEK(columns) => 해당하는 주가 몇번째 주인지 출력
6) DATEDIFF(ex1,ex2) => ex1이 ex2 로부터 날짜가 얼마나 차이나는지 출력
7) DATEADD(date, INTERVAL x time) => date의 날짜로부터 time단위의 x시간만큼 뒤가 언제인지 날짜로 출력
    ex) 2022-10-05, INTERVAL 1 YEAR -> 2023-10-05   (time에는 year,month등. 날짜관련)

여러가지 쓸만한 시간관련 함수
1) HOUR(columns) => 해당하는 시간만 출력
2) MINUTES() => 해당하는 분만 출력
3) SECOND() => 해당하는 초만 출력

여러가지 시간관련 Formatting -> 검색

Comparision Operators(비교 연산자), Logical Operators(논리 연산자)

1) Not Equal ( != )
    ex) SELECT title FROM books WHERE title != "DB Study";
        -> title이 'DB Study' 가 아닌 모든 책들에 대한 title을 출력

2) Not Like
    ex) SELECT title FROM books WHERE title Not Like '% %';
        -> title에 공백이 포함되지않은 title들을 출력

3) Greater Then ( > )
    ex) SELECT * FROM books WHERE released_year > 2005;
        -> released_year이 2005 를 넘는 데이터들만 출력.
만일 NULL이 조건에 있을경우 NULL 반환

4)  Less Then ( < )
    ex) SELECT * FROM books WHERE released_year < 2005;
        -> released_year이 2005 를 넘지 않는 데이터들만 출력

5) AND ( && )
    ex) SELECT * FROM books WHERE author_lname = 'Eggers' AND released_year > 2010;
        -> author_lname이 'Eggers' 이면서 released_year이 2010을 넘는 데이터 출력

6) OR ( || )
    알고있으므로 패스

7) BETWEEN
    만일 2004년도 보다 늦게 발매되었고 2015년도보다 빠르게 발매된 책들의 정보를 찾고싶다면
    ex) SELECT title FROM books WHERE released_year >= 2004 AND released_year <= 2015;
        -> AND 연산자를 사용하여 찾을수도있지만. Between을 사용한다면 더 단순하게 표현할수있다.
    ex) SELECT title FROM books WHERE released_year BETWEEN 2004 AND 2015;
NOT 연산자도 포함할수있다

8) Date Comparing
    CAST() 를사용해서 할수있다..

9) IN
    특정 문자열이 포함되는 데이터들을 찾아서 반환해준다.
    ex) SELECT title FROM books WHERE author_lname IN ('doraemon','jingu','bisil');
        -> 특정 문자열이 author_lname 으로 있는 결과값들을 반환
NOT 연산자도 포함할수있다.

10) MODULO ( % )
    나머지 연산자.
    ex) SELECT 2000 % 2 ;
        -> 나머지가 0이므로 0반환

11) CASE
    ex) SELECT title, released_year,
            CASE
                WHEN released_year >= 2000 THEN 'Modern Lit'
                ELSE '20th Century Lit'
            END AS GENRE
        FROM books;
    -> released_year 이 2000보다 크거나 같으면 'Modern Lit'. 아니면 '20th Century Lit'.
        cASE는 END로서 마무리할수있고, AS GENRE를 사용함으로서 출력되는 Column명을 GENRE로 변경하였다.

12) IS NULL
    해당 데이터가 NULL 인지 아닌지
    ex) SELECT * FROM books WHERE title = NULL
        -> title 이 NULL 인 데이터만 출력
NOT 연산자 포함가능

Constraints (제약)
기본적으로 Table생성시 Column 속성으로 넣는 제약조건.
1) UNIQUE
    -> UNIQEU속성을 넣을시 그 Column은 고유성(중복불가) 속성을 가지게된다.

2) CHECK( 조건 )
    -> CHECK속성을 넣을시 그 Column은 조건검사를 한뒤 조건검사값이 TRUE일경우 데이터추가를 허용한다.
        ex) age INT CHECK (age > 19) = age에 들어가는 값이 19보다 커야만 한다.

3) NAMED
Named Constraints (사용자 지정 제약조건) 은 CHECK ()를 사용할시 어떤 조건에 의해서 문제가 발생하였는지를 모르기때문에
따로 검사하는 이름을 정해줘서 예외발생시 알기쉽게 하기위함.
    -> CONSTRAINT age_over_19 CHECK (age > 19) 라고 Table생성시 포함하여 넣게되면, 데이터 삽입시
    age값을 참고하여 CHECK ( age > 19 ) 를 검사하게되고, 만일 문제가 있을경우age_over_19 라고 예외가 반환된다.

4) Mulit-Column Checks
단순히 Named Constraints를 여러 Column에 적용시킬수 있다.
    -> CONSTRAINT name_address UNIQUE (name, address) = name 과 address Column에 UNIQUE속성을 적용시키고,
    만일 예외가 발생시 name_address 명이 리턴되어 알기쉽게 나타낼수있다.

ALTER TABLE
TABLE을 추가,변경하고싶을경우.

1) Add Column (Column 추가)
    ex) ALTER TABLE companies ADD COLUMN city VARCHAR(25); -> companies라는 TABLE에서 city라는 COlumn을 추가

2) Drop Column (Column 삭제)
    ex) ALTER TABLE companies DROP COLUMN city; -> companies라는 TABLE에서 city라는 Column을 삭제

3) Renamed (Table, Column명 변경)
    ex) RENAME TABLE companies TO Cp
        -> companies라는 TABLE에서 Cp라는 이름으로 변경
    ex) ALTER TABLE companies RENAME COLUMN name TO biz_name
        -> companies라는 TABLE에서 name이라는 COLUMN 명을 biz_name으로 변경

4) Modify (Column 속성 수정)
    ex) ALTER TABLE companies MODIFY biz_name VARCHAR(100);
        -> biz_name Column의 VARHCAR속성을 VARCHAR(100)으로 변경

5) Change (Column 이름과 속성 수정)
    ex) ALTER TABLE companies CHANGE business biz_name VAHRCHAR(50);
        -> companies라는 TABLE 명을 business로 변경한뒤, biz_name VARCHAR(50) Column을 생성.

6) ADD(DROP) Constraints (제약 추가)
    ex) ALTER TALBE a ADD CONSTRAINT b CHECK (조건);  -> 제약조건 추가
    ex) ALTER TABLE a DROP CONSTRAINT b;    -> 제약조건 삭제

Relationship DB ( 서로 영향을 주고받는 관계가 있는 Table들을 만들수있다..이젠..)
현실에서는 서로 영향을 주고 받는 데이터들이 많다. ex) SNS라고 한다면 좋아요, 댓글, Id등등
보통 3가지 관계성을 가지고있는데
1. one to One (1 대 1)
    1 ㄷ 1 관계 생성 예시
    CREATE TABLE customers (
        id INT PRIMARY KEY AUTO_INCREMENT,
        first_name VARCHAR(50),
        last_name VARCHAR(50),
        email VARCHAR(50)
    );

    CREATE TABLE orders (
        id INT PRIMARY KEY AUTO_INCREMENT,
        order_date DATE,
        amount DECIMAL(8,2),
        customer_id INT,
        FOREIGN KEY (customer_id) REFERENCES customers(id)
    );
    -> customer_id 는 참조할 customers Table의 id와 데이터형식이 같아야한다. (INT)
    -> FOREIGN KEY (customer_id)를 선언함으로서 외래 키 를 설정해주었고,REFERENCES customer(id)를 통해
    -> customers이 가지고있는 id값중에 하나여야만 한다는 조건(검증)을 해줄수있다.
    -> 만일 customers에 존재하지않는 id를 orders.customer_id 에 넣는다면 예외가 발생함.

그럼 데이터 참조는 어떤식으로 할수있을까?
- SELECT Query 를 두번 작성하여 찾기.    ( CROSS JOIN )
    ex)SELECT id FROM customers WHERE last_name = 'George';
      SELECT * FROM orders WHERE customer_id = 1;
    또는 SELECT * FROM orders WHERE customer_id = (SELECT id FROM customers WHERE last_name = 'George');

- ( INNER JOIN )    Table 간 순서 상관 X 겹쳐있는 부분이 있을경우 참조가능
    ex)
        SELECT * FROM customers
       	    JOIN orders
       		    ON customers.id = orders.customer_id;
    -customers Table 이 orders 테이블과 합치는데, ON ( 조건 ) 이 맞는경우에만 SELECT 문 반환.

- ( LEFT JOIN )     하나의 테이블을 검색하는데, 겹치는 부분이 있는 다른테이블이 있을경우 참조. 없을경우 NULL
    ex)
        SELECT first_name, last_name, order_date, amount
            FROM customers
                LEFT JOIN orders
                    ON orders.customer_id = customers.id;
    [이해를 돕기위한 비교 데이터]
    - INNER JOIN 의 경우
    Boy	George	2016-02-10	99.99
    Boy	George	2017-11-11	35.50
    George	Michael	2014-12-12	800.67
    George	Michael	2015-01-03	12.50
    Bette	Davis	1999-04-11	450.25
    - LEFT JOIN 의 경우
    Boy	    George	2016-02-10	99.99
    Boy	    George	2017-11-11	35.50
    George	Michael	2014-12-12	800.67
    George	Michael	2015-01-03	12.50
    David	Bowie   NULL        NULL
    Blue	Steele  NULL        NULL
    Bette	Davis	1999-04-11	450.25

    INNER JOIN은 orders 테이블과 customers 테이블 간 ON(조건)이 맞는 경우
    LEFT JOIN은 기준 테이블인 customers를 일단 전부 반환하되, 만일 참조 Table인 orders에도 겹치는 부분이 있을경우 참조가능 없음 NULL
    LEFT JOIN은 어떨때 사용할까? -> 주문이 없는 고객은 있을수있지만, 고객이 없는 주문은 있을 수 없으므로 이런부분 체크할때 사용할듯

- ( RIGHT JOIN ) ..? LEFT랑 머가 다르지

2. one to Many (1 대 다)
3. Many to Many (다 대 다)


-> PRIMARY KEY 고유 키 (스키마를 정의할때 이 키워드를 설정할수있다 ex) Column 속성으로 넣기)
-> FOREIGN KEY 외래 키 (다른곳에서 특정 Table을 참조할때 사용하는 KEY) 참조할 고유 키와 동일한 속성이여야한다.ex) INT -> INT

여러 참조가 되어있는(FOREIGN KEY 를 통해 연결되어있는 테이블의경우) 특정 행을 삭제할때 어떻게 해야할까?
단순 DELETE를 통한 삭제는 행을 삭제했을경우 FOREIGN KEY에 위반되는 것이 있을경우 예외를 반환한다.
방법은 여러가지가 있는데, 그중 외래 키 생성시 ON DELETE CASCADE 속성을 달아주는것이다. 이럴경우 해당 키를 가진 참조값이 삭제된다면
외래 키와 연결되어있는 모든 행을 삭제한다.
    ex) FOREIGN KEY (customer_id) REFERENCES customers(id) ON DELETE CASCADE;


View란?
    -> 일종의 사용자정의 가상테이블을 생성한다.
    ex) CREATE VIEW full_reviews AS
    SELECT title, released_year, genre, rating, first_name, last_name FROM reviews
    JOIN series ON series.id = reviews.series_id
    JOIN reviewers ON reviewers.id = reviews.reviewer_id;
    = full_reviews라는 가상의 테이블이 생성되고,Column 이나 Row 정보는 SELECT 한것을 기준으로 가져간다.

View Update?
    -> 일반 Table처럼 삭제를 할려고 할떄에 DELETE 를 사용하면 에러가 발생한다.

View Replace?
    -> ex) CREATE OR REPLACE VIEW view_test AS
            SELETE * FROM series ORDER BY released_year DESC;
    = CREATE OR REPLACE (없으면 만들고, 있을경우 변경)

Window Function?
 GROUP BY 와 아주 비슷하다.단, Window function은 모든행에 대한 결과값을 추가한다.
ex) SELECT emp_no, department, salary, AVG(salary) OVER(PARTITION BY department)
    AS dept_avg FROM emps;
    -> emp_no   department          salary  dept_avg
       20       customer_service    56000   55500.0000
       21       customer_service    55000   55500.0000
       18       sales               59000   59500.0000
       12       sales               60000   59500.0000
    당장은 의미불명일수있으나, 아마도 AVG(salary) OVER(PARTITION BY department)의 뜻은
    department를 기준으로 일종의 그룹을 나눈뒤 월급을 기준으로 평균을 내라 라는 의미로 생각된다.
    SELECT department, AVG(salary) FROM emps GROUP BY department; 의 결과와 유사하다.
    단 GROUP BY 의 경우 하나의 행으로 압축?해버리는데 반해 Window Function은 각각의 개별행이
    남아있다. 둘다 필요에따라 나눠쓰면될듯

Window Function
1) OVER()
모든행에 특정한 행을 추가하는 함수인듯. AVG,MAX,MIN,SUM 등등 여러 집계함수를 사용할수있다.
ex) SELECT emp_no,department, salary, AVG(salary) OVER() FROM employees;
    -> group by 를 하지않았기 떄문에 각 Column(emp_no, department, salary)와 행들이 출력되고,
    거기에 더하여 AVG(salary)를 계산한 행이 추가되어 결과가 나온다.
    emp_no  department  salary  AVG(salary) OVER()
    	1	engineering	80000	68428.5714
    	2	engineering	69000	68428.5714
    	3	engineering	70000	68428.5714
OVER()에는 인자로 넣을수있는 PARTITION BY 가 있다.
ex) AVG(salary) OVER(PARTITION BY department) FROM employees;
    -> 각 행에 대해서 AVG(salary)를 추가하긴하는데,여기에 department를 기준으로 그룹을 나눈뒤 AVG(salary)
    를 한 값을 각 해당하는 department에 추가하여 결과로 반환한다.
    이 부분은 위에 맨처음 WINDOW FUNCTION을 설명할때 사용한
     -> emp_no   department          salary  dept_avg
           20       customer_service    56000   55500.0000
           21       customer_service    55000   55500.0000
           18       sales               59000   59500.0000
           12       sales               60000   59500.0000
           과 유사한 값이 나오게된다. 각 department에 맞게끔 평균을 낸 값이 그 row에 추가


생각해봐야 하는 쿼리문의 경우.
1) 각 작가의 첫번째 책 발매연도를 알고싶어
SELECT author_fname, author_lname, MIN(released_year) FROM books GROUP BY author_fname, author_lname;
    -> author_fname, author_lname을 기준으로 그룹을 나눠서 그중 released_year이 가장 낮은 것을 반환

2) 가장 제목이 긴 책을 출간한 작가의 성+이름을 출력
SELECT CONCAT(author_fname,' ',author_lname) AS author FROM books
WHERE char_length(title) = (SELECT MAX(char_length(title)) FROM books) GROUP BY author;

3) 각 사람별로 시킨 가격의 총합하여 가격순으로 정렬
- INNER JOIN
SELECT first_name, last_name, SUM(amount)as total FROM customers
	JOIN orders
		ON customers.id = orders.customer_id
			GROUP BY first_name, last_name
				ORDER BY total;

- LEFT JOIN
SELECT
    first_name,last_name,IFNULL(SUM(amount), 0) AS money_spent
        FROM customers
            LEFT JOIN orders
                ON customers.id = orders.customer_id
                    GROUP BY first_name , last_name;
IFNULL(1,2)은 1번인자에 값을 넣고 만일 1번 값이 NULL일경우 2번값을 반환하도록 하는 함수

4) series테이블의 title의 평점을 reviews테이블에서 가져와서 평점의 평균을 낮은순서대로 정렬

SELECT title, ROUND(AVG(rating),2) as avg_rating FROM series
	JOIN reviews
		ON series.id = reviews.series_id
			GROUP BY title
				ORDER BY AVG(rating);

5) review가 없는 시리즈의 제목을 출력
SELECT title as unreview_series FROM series
    LEFT JOIN reviews
        ON series.id = reviews.series_id
            WHERE rating IS NULL;
-> LEFT JOIN 은 series를 일단 나열하고, 그중 reviews에 겹치는 부분(ON series.id = reviews.series_id) 에 해당하는
    부분이 있을경우 데이터에 넣고, 없을경우 NULL 반환한다. 그러므로 rating 부분의 값이 NULL 일경우 아무도 평가를 매기지
    않았다는 뜻이므로 review가 없는 title값이 출력된다.

6) 각 장르별 평균 평점
SELECT genre,AVG(rating) as avg_rating FROM series
    JOIN reviews ON series.id = reviews.series_id
        GROUP BY genre;

7) CASE, LEFT JOIN, GROUP BY 등을 사용하여 원하는 데이터형식으로 데이터 뽑아내기

SELECT first_name,last_name,COUNT(rating) as COUNT,IFNULL(MIN(rating),0) as MIN,
IFNULL(MAX(rating),0) as MAX,IFNULL(AVG(rating),0) as AVG,
CASE
	WHEN COUNT(rating) > 0 THEN 'ACTIVE'
    ELSE 'INACTIVE'
END AS STATUS
FROM reviewers
	LEFT JOIN reviews
		ON reviewers.id = reviews.reviewer_id
			GROUP BY first_name,last_name;

8) 3개의 테이블을 JOIN하여 원하는 데이터형식 출력
SELECT title, rating, CONCAT(first_name,' ',last_name) as reviewer FROM series
	JOIN reviews
		ON reviews.series_id = series.id
	JOIN reviewers
        ON reviews.reviewer_id = reviewers.id
	ORDER BY title;


############################## 에러 목록 ################################
1)
org.springframework.beans.factory.BeanDefinitionStoreException: Failed to parse configuration class [jpabook.jpashop.JpashopApplication]

-> 현재 Jpashop에서 같은 이름의 클래스가 존재한다.
더 아래줄에서 나온 에러를 읽어보자.
Caused by: org.springframework.context.annotation.ConflictingBeanDefinitionException: Annotation-specified bean name 'memberRepository' for bean class [jpabook.jpashop.repository.MemberRepository] conflicts with existing, non-compatible bean definition of same name and class [jpabook.jpashop.MemberRepository]
걍 단순하게 MemberRepository라는 이름으로 등록된 Bean이 두개나 있다고 한다.. 친절하게 어디경로인지도 알려준다. 잘확인해보자.

2)
java.lang.NullPointerException: Cannot invoke "jakarta.persistence.EntityManager.createQuery(String, java.lang.Class)" because "this.em" is null

-> 현재 "jakarta.persistence.EntityManager.createQuery(String, java.lang.Class)" 를 호출할수가없는데, 왜나면 em값이 Null이기 떄문이다..
em? 은 지금 EntityManager의 필드명인데..? 그렇다면 EntityManager가 제대로 호출이 되지않았거나, Bean등록이 되지않았다는 뜻이다.
확인해보니 Lombok에서 제공하는 @RequiredArgsConstructor 를 사용하려하는데, 이 어노테이션은 final을 선언한 필드에만 적용된다.
final을 넣고나니 오류가 해결되었다.

3)
org.springframework.dao.InvalidDataAccessApiUsageException: id to load is required for loading

-> id 값이 제대로 불러오도록 준비되지않아서 생기는에러..
따로 설정해주지않는이상.. 여러 엔티티를 포함하는 엔티티를 persist하기 위해서는 미리 그에 속하는 Entity를 persist해줘야한다.
이거 하기싫으면 CASCADE옵션을 따로 넣어준다거나.