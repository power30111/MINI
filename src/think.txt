
===============Lombok==========================================
@RequiredArgsConstructor
초기화 되지않은 final 필드, @NonNull이 붙은 필드에 대해 생성자를 생성한다.
즉 의존성 주입을 하기위해서 사용하는듯.

@Getter @Setter
이 어노테이션이 붙은 필드에는 자동적으로 getXXX(), setXXX()를 생성해준다.

@NoArgsConstructor
파라미터가 없는 기본 생성자 생성

@AllArgsConstructor
모든 필드값을 파라미터로 받는 생성자를 생성

@ToString
toString()메소드 자동생성

@Data
@Getter @Setter @RequiredArgsConstructor @ToString @EqualsAndHashCode 를 자동생성해준다

=================DB============================================
DataBase?
-> 데이터의 집합. ex) 전화번호부 [이름]-[전화번호]
-> 현재는 접근 가능한 인터페이스를 가지고있으면서 컴퓨터화되어있는 데이터의 구조화된 집합

DBMS, RDBMS?
--> DMS는 DataBase Management System(DB관리 시스템)
--> RDBMS 은 관계형 데이터베이스 관리 시스템인듯?
ex) PostgreSQL, MySQL, Oracle DB, SQLite들은 기본적으론 데이터베이스 관리 시스템이다.

SQL? MySQL?
--> SQL은 데이터베이스 데이터에 접근할때 사용하는 언어 = 구조화된 쿼리 언어
ex) Find All Users Who Are 18 Or Older (모든 유저들중 나이가 18이거나 더많은사람을 찾아라)
    = SELECT * FROM Users WHERE Age  >= 18; (SQL로 보낸 같은 의미를 가진 명령문)
--> MySQL은 SQL을 구현하는 DB 관리 시스템

Table?
--> 데이터베이스(관계형)는 여러개의 테이블로 이루어져있다. 테이블은 데이터를 담고있으며,
데이터의 형태와 형식을 설명하고 그 형식을 따른 데이터들을 수집하여 보관한다.
Table에는 Field(Columns),Type(data_type), Null(값이 Null일수있는지),Key,Default(기본값)등을 설정할수있다.
ex) 고양이의 데이터베이스가 있어야한다고 치자. 그렇다면 이름, 종, 나이를 넣는다고 하였을때
각 테이블 Columns의 제목(Headers)는 각각 Name, Breed, Age 이다. 그 이후 각 행(Rows)에 맞춰서
데이터가 들어가게된다. 이때 같은 행에 위치한 데이터들은 하나의 연관된 데이터라고 볼수있다.(엑셀마냥)

Data Type?
--> 테이블에는 각각의 Columns에 들어가게될 데이터형식을 지정해야만 한다. int, String(VarChar), char 등등..
데이터의 일관성을 부여하여 예상외의 예외를 줄일수있다. 또한 최대 문자수를 지정해줄수있다.

mysql주석은 --로 표현할수있다.

Primary Key?
--> unique identifier (고유 식별자) 로서 테이블에서 고유한 값을 가지게 하여
모든 column에 해당하는 값이 동일하더라도 primary key를 활용하여 구별할수있다.
기본적으로 Not null 속성을 포함하며, 중복될수없고, AUTO_INCREMENT 속성을 추가하여 기본적으로 1씩 추가하게끔 만들수있다.

STRING FUNCTION?
SQL에서 실행할수있는 간단한 함수인듯(엑셀처럼)
CONCAT, SUBSTRING, REPLACE, REVERSE, CHAR_LENGTH, UPPER, LOWER 등등..

SELECT * FROM **
--> *은 전체를 의미한다. **에서 전체를 조회한다.

ORDER BY #
--> #의 값 기준으로 오름차순 정렬

ORDER BY DESC #
--> #의 값 기준으로 내림차순 정렬

DROP TABLE #
--> #이라는 테이블 삭제

USE <database name>
--> 이 데이터베이스를 사용

SELECT database()
--> 현재 사용하는 데이터베이스

CREATE TABLE <tablename>
--> (
        column_name data_type,
        column_name data_type
    );
새 테이블을 만들려면 테이블 이름과 데이터타입, column명을 명시해야줘야한다.
ex) CREATE TABLE cats
        (
            name VARCHAR(100) not Null default 'unnamed',   #name 에는 100글자까지 들어갈수있고 null일수없으며 기본값이있다.
            age INT                                         #age 에는 글자수 제한이 없고 null일수있으며 기본값이 없다.
            cat_id int not null PRIMARY key AUTO_INCREMENT  #cat_id 는 고유식별자이고, 자동적으로 1씩 증가한다.
        );

SHOW TABLES
--> 현재 위치한 데이터베이스에서 존재하는 테이블확인

SHOW COLUMNS FROM <table_name>
--> <table_name>에 정의되어있는 columns 정보 확인
DESCRIBE <table_name>이나 DESC <table_name> 또한 동일한 쿼리문이다.

DROP TABLE <table_name>
--> <table_name>이란 이름의 TABLE을 삭제한다. ##주의해서 사용해야한다. 테이블에 많은 정보를 담고있었을경우 되돌릴수없다.

INSERT
--> INSERT 키워드를 사용하여 데이터를 삽입할수있다.
ex) INSERT INTO <table_name>(column_name1, coulmn_name2) VALUES ('data',data);
이때 column_name1에 들어갈 내용이 'data' 이고 column_name2 에 들어갈 내용이 data이다.
각 선언한 순서대로 넣어지게된다는점을 유의해야한다(데이터형식과 원치않는 내용이 들어가는것을 방지하기위해서)
다중삽입 VALUES ('data',data),('data',data), ... 이런식

SELECT * FROM <table_name>
--> <table_name>에 있는 데이터들을 전부 조회

쿼리문에는 큰따옴표보다 작은 따옴표를 사용하는것이 혹여나 다른 Db와의 혼란을 줄일수있다.
"mario's pizza" = 'mario\'s pizza';

CRUD
--> CREATE, READ, UPDATE, DELETE
DB에서 대개 기본적으로 지원하는 기능

SELECT  (READ)
--> SELECT (Column_name) FROM (TABLE_name)  2개이상의 Column을 조회할수도있음 , 으로 구분하는듯
SELECT 은 기본적으로 조회하고싶은 Column명을 적어주고, FROM으로 조회할 TABLE을 선택한다음 WHERE로 정보를 추려서 가져온다.

Update  (UPDATE)
--> UPDATE (TABLE_name) SET (변경할 column과 Row명)  WHERE(조건)
ex) UPDATE cats SET breed='shortHair' WHERE breed='Tabby' -> cats 테이블에서 breed가 Tabby인걸 shortHair로 바꾼다.

Delete  (DELETE)
--> DELETE FROM (TABLE_name) WHERE (조건);
ex) DELETE FROM cats WHERE name='Egg'; -> cats테이블에서 name='Egg'인 것을 삭제
#주의 DELETE FROM (TABLE)을 하면 TABLE 전체가 삭제되므로 주의해야한다.

WHERE
--> WHERE은 일종의 조건문과 같다.
ex) SELECT * FROM cats WHERE age>4; == cats 테이블에서 모든Column을 조회하는데, 그중 age값이 4보다 큰값만 조회

AS
--> Column 명을 해당쿼리문에 한하여 변경할수있다.
ex) SELECT cat_id as id, name FROM cats; -> cat_id라는 column이 id로 출력된다.

#문자열 함수를 사용할때에 Function()에서 ()를 띄어쓰기 하면 예외가 터지므로, 꼭 붙여서 사용하자
문자열 함수 예시
SELECT CONCAT(SUBSTRING(title,1,10),'...')as short_title FROM books;
SELECT CONCAT_WS('.',SUBSTR(author_fname,1,1),SUBSTR(author_lname,1,1)) as Initial From books;

CONCAT
--> 문자열을 결합,연결하는 함수.
ex) SELECT CONCAT('My','S','QL'); -> 'MYSQL'
ex) SELECT CONCAT(author_fname,author_lname) FROM books; ->fname+lname로 반환된 문자열 조회
#단 중간에 NULL값이 있다면 NULL이 반환되고, 숫자를 넣어도 문자열로 반환된다. CONCAT(f+l)로 column명이 나오는데
as 써서바꿀수있음

CONCAT_WS
--> CONCAT과 비슷하지만 첫번쨰 인자값에 넣은값들이 문자들이 연결되는 사이에 들어가게된다.
ex) SELECT CONCAT_WS(' - ', title, name) FROM books -> title - name 이런식으로 나옴

SUBSTRING
--> 문자열중 일부분을 반환    SUBSTRING(문자열,시작인덱스,시작인덱스부터 몇개까지 반환할건지)
ex) SELECT SUBSTRING('abcdefg',3); -> cdefg
ex) SELECT SUBSTRING('abcdefg',FROM 3) -> cdefg
ex) SELECT SUBSTRING('abcdefg',3,2) ->cd
#MYSQL은 인덱스번호가 1번부터 시작한다는점을 주의하자, 또한 인자값에 음수도 가능하다.
#SUBSTR() 또한 같은 의미.

REPLACE
--> 문자열 일부분을 변환
SELECT REPLACE (문자열,From_str,to_str) 문자열에서 From_str이라는 문자열이 to_str로 변환된다.
ex) SELECT REPLACE('Hello World','Hell','OuO') -> OuOo World
ex) SELECT REPLACE(title, ' ','-') FROM books;

REVERSE
--> 문자열을 반대로 반환
SELECT REVERSE('abc') -> cba
SELECT concat(author_fname, REVERSE(author_fname))as Test FROM books;

CHAR_LENGTH
--> 문자열의 길이 반환
ex) SELECT CHAR_LENGTH('Hello World') -> 11

LENGTH
--> 문자열의 Byte 길이반환

UPPER, LOWER
--> 문자열을 대문자로 바꾸거나 소문자로 변경
ex) SELECT UPPER('Hello World') -> HELLO WORLD
ex) SELECT LOWER('Hello Wrold') -> hello world
UCASE,LCASE 또한 같은 함수

INSERT
--> 문자열에 문자열을 삽입하는 함수   INSERT(str,pos,len,newstr)
ex) SELECT INSERT('Quadratic',3,4,'What') -> 'Quwhattic'
? 이정도면 거의 REPLACE이지만, 위치(pos)를 지정한뒤 그로부터 임의의 길이까지(len)을 전부
새로운 문자열로(newstr)로 대체한다는점에서 다르다.

LEFT, RIGHT
--> 문자열에서 왼쪽(오른쪽)에서 임의의 거리만큼 떨어져있는 문자를 반환
ex) SELECT LEFT('football',5) -> b
ex) SELECT RIGHT('basketball',5) -> t

REPEAT
--> 특정 문자열을 반복한것을 반환
ex) SELECT REPEAT('a',3) -> aaa

trim
--> 선행 및 후행 공백 제거
ex) SELECT TRIM('       hi       '); -> hi          (인자가없을경우 공백제거)
ex) SELECT TRIM(LEADING '.' FROM ''.....san antonio...') -> san antonio...  (선행 제거)
ex) SELECT TRiM(BOTH 'x' FROM 'xxxbarxxx') -> bar   (선행,후행 제거)
ex) SELECT TRIM(TRAILING 'x' FROM 'xxxbarxxx') -> xxxbar (후행 제거)
#단 단순 trim은 중간에 있는 공백은 제거하지않는다.


